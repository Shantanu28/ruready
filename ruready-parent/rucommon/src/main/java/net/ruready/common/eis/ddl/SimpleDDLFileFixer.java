/*****************************************************************************************
 * Source File: TestFileReader.java
 ****************************************************************************************/
package net.ruready.common.eis.ddl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;

import net.ruready.common.exception.ApplicationException;
import net.ruready.common.rl.CommonNames;
import net.ruready.common.text.TextUtil;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Reads a database schema (DDL) file generated by Hibernate Tools (3.2.9 or earlier) and
 * fixes the order of SQL statements so that table drops and creations come before foreign
 * key drops/creations. This makes the DDL file be properly executible on a fresh
 * database, which is not the case with the original output of Hibernate Tools.
 * <p>
 * -------------------------------------------------------------------------<br>
 * (c) 2006-2007 Continuing Education, University of Utah<br>
 * All copyrights reserved. U.S. Patent Pending DOCKET NO. 00846 25702.PROV
 * <p>
 * This file is part of the RUReady Program software.<br>
 * Contact: Nava L. Livne <code>&lt;nlivne@aoce.utah.edu&gt;</code><br>
 * Academic Outreach and Continuing Education (AOCE)<br>
 * 1901 East South Campus Dr., Room 2197-E<br>
 * University of Utah, Salt Lake City, UT 84112-9359<br>
 * U.S.A.<br>
 * Day Phone: 1-801-587-5835, Fax: 1-801-585-5414<br>
 * <br>
 * Please contact these numbers immediately if you receive this file without permission
 * from the authors. Thank you.<br>
 * -------------------------------------------------------------------------
 * 
 * @author Oren E. Livne <code>&lt;olivne@aoce.utah.edu&gt;</code>
 * @version Jul 24, 2007
 */
public class SimpleDDLFileFixer
{
	// ========================= CONSTANTS =================================

	/**
	 * A logger that helps identify this class' printouts.
	 */
	@SuppressWarnings("unused")
	private static final Log logger = LogFactory.getLog(SimpleDDLFileFixer.class);

	/**
	 * Creates a new database. A macro.
	 */
	private static final String DROP_DATABASE_STATEMENT(final String databaseName)
	{
		return "drop database " + databaseName + ";" + CommonNames.MISC.NEW_LINE_CHAR
				+ "create database " + databaseName + ";" + CommonNames.MISC.NEW_LINE_CHAR
				+ "use " + databaseName + ";" + CommonNames.MISC.NEW_LINE_CHAR;
	}

	/**
	 * used to recognize table-related statements.
	 */
	private static final String DROP_TABLE_PREFIX = "drop table if exists";

	private static final String CREATE_TABLE_PREFIX = "create table";

	private static final String DROP_FOREIGN_KEY_PATTERN = "drop foreign key";

	// ========================= FIELDS ====================================

	/**
	 * ====================== Input and parameters ==================
	 */

	/**
	 * Input File name (original DDL file)
	 */
	private final String inputFileName;

	/**
	 * Output File name (fixed DDL file).
	 */
	private final String outputFileName;

	/**
	 * Name of database we are exporting to.
	 */
	final String databaseName;

	// Stop on first error or continue processing the entire file in any event
	private boolean stopOnFirstError = true;

	/**
	 * Input stream used to read lines from the input file
	 */
	private BufferedReader reader;

	/**
	 * Output stream used to write lines into the output file
	 */
	private FileOutputStream writer;

	/**
	 * Output variables
	 */
	private int numLinesRead;

	private int numErrors;

	/**
	 * ====================== Target variables ======================
	 */

	/**
	 * Accumulates "drop table" statements.
	 */
	private StringBuffer tableSQL = TextUtil.emptyStringBuffer();

	/**
	 * Accumulates the rest of the SQL statements.
	 */
	private StringBuffer normalSQL = TextUtil.emptyStringBuffer();

	/**
	 * Accumulates key drop SQL statements.
	 */
	private StringBuffer keySQL = TextUtil.emptyStringBuffer();

	// ========================= CONSTRUCTORS ==============================

	/**
	 * Construct a test file reader.
	 * 
	 * @param fileName
	 *            file name to read tests from
	 */
	public SimpleDDLFileFixer(final String inputFileName, final String outputFileName,
			final String databaseName) throws ApplicationException
	{
		String baseDir = System.getProperty(CommonNames.JUNIT.ENVIRONMENT.BASE_DIR);
		this.inputFileName = (baseDir != null) ? baseDir + File.separator + inputFileName
				: inputFileName;
		this.outputFileName = (baseDir != null) ? baseDir + File.separator
				+ outputFileName : outputFileName;

		// Set parameter default values
		this.setStopOnFirstError(false);

		// Try to open the input file
		try
		{
			reader = new BufferedReader(new FileReader(this.inputFileName));
			logger.info("Reading tests from " + this.inputFileName);
		}
		catch (Exception e)
		{
			logger.error("Test file '" + this.inputFileName + "' could not be opened");
			throw new ApplicationException("Input file '" + this.inputFileName
					+ "' could not be opened; working directory is "
					+ System.getProperty("user.dir") + "; baseDir is " + baseDir);
		}

		// Try to open the output file
		try
		{
			// Don't append - overwrite
			writer = new FileOutputStream(outputFileName, false);
		}
		catch (FileNotFoundException e)
		{
			throw new ApplicationException("Output file '" + this.outputFileName
					+ "' could not be opened; working directory is "
					+ System.getProperty("user.dir") + "; baseDir is " + baseDir);
		}

		this.databaseName = databaseName;
	}

	// ========================= PUBLIC METHODS ============================

	/**
	 * Run the SQL statement order fix on the DDL file.
	 */
	public final void run()
	{
		// reset counters
		numLinesRead = 0;
		numErrors = 0;

		// Loop through the expressions in pairs
		logger.debug("Reading and comparing expressions...");
		while (true)
		{
			boolean hasError = false;
			String inputStr = null;
			try
			{
				// Read a line
				inputStr = getNextLine(); // returns null when end of file is

				// Either line may be null when the end of file is reached
				if (inputStr == null)
				{
					// logger.info("Reached end of file.");
					break;
				}

				// Process the line
				processLine(inputStr);
			}
			catch (Exception e)
			{
				hasError = true;
				logger.error(e.getMessage());
				e.printStackTrace(System.err);
			}
			if (hasError)
			{
				numErrors++;
				logger.error("Line " + (numLinesRead - 2) + ": " + inputStr);
				if (isStopOnFirstError())
				{
					break;
				}
			}
		}

		// Closing remarks
		if (numErrors == 0)
		{
			logger.info(numLinesRead + " line(s) processed. " + numErrors
					+ " error(s) found.");
		}
		else
		{
			logger.error(numLinesRead + " line(s) processed. " + numErrors
					+ " error(s) found.");

		}

		writeOutput();
	}

	// ========================= PRIVATE METHODS ===========================

	/**
	 * Parses a single line from the reader and trim it.
	 * 
	 * @return line string representation. Returns <code>null</code> when the end of the
	 *         file is reached.
	 * @throws Exception
	 *             when IOException occurs, parsing fails, or when evaluation fails
	 */
	private String getNextLine() throws IOException
	{
		String line;
		StringBuffer command = TextUtil.emptyStringBuffer();

		// Cycle till a valid line is found
		boolean validLine = false;
		do
		{
			// Read and trim a line
			line = reader.readLine(); // returns null on end of file
			if (line == null)
			{
				return null;
			}
			line = line.trim();
			numLinesRead++;

			// Every line is a data line for now
			if (CommonNames.MISC.EMPTY_STRING.equals(line))
			{
				// Data line, return it for processing
				validLine = true;
			}
			else
			{
				// Append to command until an empty line is found
				command.append(line).append(CommonNames.MISC.SPACE_CHAR);
			}
		}
		while (!validLine);
		return command.toString();
	}

	/**
	 * Process a comment.
	 * 
	 * @param line
	 *            comment line string
	 */
	protected void processComment(String line)
	{

	}

	/**
	 * Process a data line.
	 * 
	 * @param line
	 *            data line string
	 */
	protected void processLine(String line)
	{
		if (CommonNames.MISC.EMPTY_STRING.equals(line))
		{
			// Skip empty lines
			return;
		}

		// Saving line in potentially long SQL string buffer caches for now; memory
		// usage can later be reduced by writing the buffers to a file as we go.
		if (line.startsWith(DROP_TABLE_PREFIX) || line.startsWith(CREATE_TABLE_PREFIX))
		{
			tableSQL.append(line).append(CommonNames.MISC.NEW_LINE_CHAR);
		}
		else if (line.contains(DROP_FOREIGN_KEY_PATTERN))
		{
			// Foreign key drop command
			keySQL.append(line).append(CommonNames.MISC.NEW_LINE_CHAR);
		}
		else
		{
			normalSQL.append(line).append(CommonNames.MISC.NEW_LINE_CHAR);
		}
	}

	/**
	 * Write output file.
	 */
	protected void writeOutput()
	{
		try
		{
			// Start by wiping off the existing database.
			writer.write(SimpleDDLFileFixer.DROP_DATABASE_STATEMENT(databaseName).toString()
					.getBytes());
			// Write drop statements first, then rest of statements
			writer.write(tableSQL.toString().getBytes());
			// writer.write(keySQL.toString().getBytes());
			writer.write(normalSQL.toString().getBytes());
			writer.close();
			logger.info("Buffer contents written to output file.");
		}
		catch (IOException e)
		{
			throw new ApplicationException(e, "Error writing output");
		}
	}

	// ========================= GETTERS & SETTERS =========================

	/**
	 * @return the fileName
	 */
	public String getInputFileName()
	{
		return inputFileName;
	}

	/**
	 * @return the outputFileName
	 */
	public String getOutputFileName()
	{
		return outputFileName;
	}

	/**
	 * @return the numErrors
	 */
	public int getNumErrors()
	{
		return numErrors;
	}

	/**
	 * @return the numLinesRead
	 */
	public int getNumLinesRead()
	{
		return numLinesRead;
	}

	/**
	 * @return
	 * @see net.ruready.common.junit.entity.LineReaderTarget#isStopOnFirstError()
	 */
	public boolean isStopOnFirstError()
	{
		return stopOnFirstError;
	}

	/**
	 * @param stopOnFirstError
	 * @see net.ruready.common.junit.entity.LineReaderTarget#setStopOnFirstError(boolean)
	 */
	public void setStopOnFirstError(boolean stopOnFirstError)
	{
		this.stopOnFirstError = stopOnFirstError;
	}
}
